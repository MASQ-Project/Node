// Copyright (c) 2019, MASQ (https://masq.ai) and/or its affiliates. All rights reserved.

use crate::sub_lib::wallet::Wallet;
use ethereum_types::{Address, U256};
use ethsign::Signature;
use ethsign_crypto::Keccak256;
use masq_lib::blockchains::chains::Chain;
use rlp::{Encodable, RlpStream};
use serde_derive::{Deserialize, Serialize};

/// Description of a Transaction, pending or in the chain.
#[derive(Debug, Default, Clone, PartialEq, Deserialize, Serialize)]
pub struct RawTransaction {
    /// Nonce
    pub nonce: U256,
    /// Recipient (None when contract creation)
    pub to: Option<Address>,
    /// Transfered value
    pub value: U256,
    /// Gas Price
    #[serde(rename = "gasPrice")]
    pub gas_price: U256,
    /// Gas limit
    #[serde(rename = "gasLimit")]
    pub gas_limit: U256,
    /// Input data
    pub data: Vec<u8>,
}

impl RawTransaction {
    /// Signs and returns the RLP-encoded transaction
    pub fn sign(&self, wallet: &Wallet, chain: Chain) -> Vec<u8> {
        let chain_id = chain.rec().num_chain_id;
        let hash = self.tx_hash(chain_id);
        let sig = ecdsa_sign(&hash, wallet, chain_id);
        let mut tx = RlpStream::new();
        tx.begin_unbounded_list();
        self.encode(&mut tx);
        tx.append(&sig.v);
        tx.append(&sig.r.to_vec());
        tx.append(&sig.s.to_vec());
        tx.finalize_unbounded_list();
        tx.out()
    }

    fn tx_hash(&self, chain_id: u64) -> Vec<u8> {
        let mut hash = RlpStream::new();
        hash.begin_unbounded_list();
        self.encode(&mut hash);
        hash.append(&chain_id.rlp_bytes());
        hash.append(&U256::zero());
        hash.append(&U256::zero());
        hash.finalize_unbounded_list();
        hash.out().keccak256().to_vec()
    }

    fn encode(&self, s: &mut RlpStream) {
        s.append(&self.nonce);
        s.append(&self.gas_price);
        s.append(&self.gas_limit);
        if let Some(ref t) = self.to {
            s.append(t);
        } else {
            s.append(&vec![]);
        }
        s.append(&self.value);
        s.append(&self.data);
    }
}

fn ecdsa_sign(hash: &dyn AsRef<[u8]>, wallet: &Wallet, chain_id: u64) -> Signature {
    match wallet.sign(&hash) {
        Ok(s) => Signature {
            v: (s.v as u64 + chain_id * 2 + 35) as u8,
            r: s.r,
            s: s.s,
        },
        Err(e) => panic!("{:?}", e),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::blockchain::bip32::Bip32ECKeyPair;
    use ethereum_types::H256;

    #[derive(Deserialize)]
    struct Signing {
        signed: Vec<u8>,
        private_key: H256,
    }

    #[test]
    fn signs_transaction_for_eth_mainnet() {
        let signatures = &[
            &[
                248, 108, 9, 133, 4, 168, 23, 200, 0, 130, 82, 8, 148, 53, 53, 53, 53, 53, 53, 53,
                53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 136, 13, 224, 182, 179, 167,
                100, 0, 0, 128, 37, 160, 40, 239, 97, 52, 11, 217, 57, 188, 33, 149, 254, 83, 117,
                103, 134, 96, 3, 225, 161, 93, 60, 113, 255, 99, 225, 89, 6, 32, 170, 99, 98, 118,
                160, 103, 203, 233, 216, 153, 127, 118, 26, 236, 183, 3, 48, 75, 56, 0, 204, 245,
                85, 201, 243, 220, 100, 33, 75, 41, 127, 177, 150, 106, 59, 109, 131,
            ][..],
            &[
                248, 106, 128, 134, 213, 86, 152, 55, 36, 49, 131, 30, 132, 128, 148, 240, 16, 159,
                200, 223, 40, 48, 39, 182, 40, 92, 200, 137, 245, 170, 98, 78, 172, 31, 85, 132,
                59, 154, 202, 0, 128, 37, 160, 9, 235, 182, 202, 5, 122, 5, 53, 214, 24, 100, 98,
                188, 11, 70, 91, 86, 28, 148, 162, 149, 189, 176, 98, 31, 193, 146, 8, 171, 20,
                154, 156, 160, 68, 15, 253, 119, 92, 233, 26, 131, 58, 180, 16, 119, 114, 4, 213,
                52, 26, 111, 159, 169, 18, 22, 166, 243, 238, 44, 5, 31, 234, 106, 4, 40,
            ][..],
            &[
                248, 117, 128, 134, 9, 24, 78, 114, 160, 0, 130, 39, 16, 128, 128, 164, 127, 116,
                101, 115, 116, 50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 96, 0, 87, 38, 160, 122, 155, 12, 58, 133, 108, 183, 145, 181,
                210, 141, 44, 236, 17, 96, 40, 55, 87, 204, 250, 142, 83, 122, 168, 250, 5, 113,
                172, 203, 5, 12, 181, 160, 9, 100, 95, 141, 167, 178, 53, 101, 115, 131, 83, 172,
                199, 242, 208, 96, 246, 121, 25, 18, 211, 89, 60, 94, 165, 169, 71, 3, 176, 157,
                167, 50,
            ][..],
        ];
        assert_signature(Chain::EthMainnet, signatures)
    }

    //TODO this signature is quite likely to change with GH-503 where we finally should be able to do things right
    #[test]
    fn signs_transactions_for_poly_mainnet() {
        let signatures = &[
            &[
                248, 108, 9, 133, 4, 168, 23, 200, 0, 130, 82, 8, 148, 53, 53, 53, 53, 53, 53, 53,
                53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 136, 13, 224, 182, 179, 167,
                100, 0, 0, 128, 53, 160, 34, 13, 81, 82, 206, 70, 134, 49, 143, 10, 66, 79, 96,
                249, 63, 140, 17, 135, 216, 145, 175, 234, 8, 238, 161, 69, 5, 190, 183, 163, 90,
                134, 160, 94, 219, 237, 37, 113, 169, 209, 250, 15, 153, 45, 20, 132, 111, 156, 28,
                206, 235, 186, 138, 41, 200, 63, 104, 95, 121, 175, 56, 170, 37, 51, 27,
            ][..],
            &[
                248, 106, 128, 134, 213, 86, 152, 55, 36, 49, 131, 30, 132, 128, 148, 240, 16, 159,
                200, 223, 40, 48, 39, 182, 40, 92, 200, 137, 245, 170, 98, 78, 172, 31, 85, 132,
                59, 154, 202, 0, 128, 53, 160, 106, 244, 39, 119, 163, 186, 125, 0, 250, 54, 66,
                116, 60, 6, 4, 172, 59, 246, 24, 56, 15, 64, 195, 131, 201, 61, 221, 168, 151, 66,
                174, 229, 160, 20, 85, 103, 16, 149, 143, 80, 93, 106, 159, 216, 157, 13, 138, 224,
                247, 72, 72, 109, 31, 76, 141, 16, 152, 181, 162, 209, 217, 217, 82, 143, 89,
            ][..],
            &[
                248, 117, 128, 134, 9, 24, 78, 114, 160, 0, 130, 39, 16, 128, 128, 164, 127, 116,
                101, 115, 116, 50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 96, 0, 87, 53, 160, 148, 34, 231, 238, 23, 203, 20, 209, 110, 54,
                66, 197, 106, 111, 255, 231, 247, 67, 156, 169, 108, 110, 9, 254, 177, 115, 0, 169,
                41, 205, 123, 97, 160, 41, 239, 67, 106, 246, 11, 11, 22, 125, 193, 238, 220, 232,
                145, 91, 154, 227, 96, 160, 145, 151, 27, 173, 22, 124, 194, 153, 165, 190, 172,
                53, 6,
            ][..],
        ];
        assert_signature(Chain::PolyMainnet, signatures)
    }

    #[test]
    fn signs_transaction_for_ropsten() {
        let signatures = &[
            &[
                248, 108, 9, 133, 4, 168, 23, 200, 0, 130, 82, 8, 148, 53, 53, 53, 53, 53, 53, 53,
                53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 136, 13, 224, 182, 179, 167,
                100, 0, 0, 128, 41, 160, 8, 220, 80, 201, 100, 41, 178, 35, 151, 227, 210, 85, 27,
                41, 27, 82, 217, 176, 64, 92, 205, 10, 195, 169, 66, 91, 213, 199, 124, 52, 3, 192,
                160, 94, 220, 102, 179, 128, 78, 150, 78, 230, 117, 10, 10, 32, 108, 241, 50, 19,
                148, 198, 6, 147, 110, 175, 70, 157, 72, 31, 216, 193, 229, 151, 115,
            ][..],
            &[
                248, 106, 128, 134, 213, 86, 152, 55, 36, 49, 131, 30, 132, 128, 148, 240, 16, 159,
                200, 223, 40, 48, 39, 182, 40, 92, 200, 137, 245, 170, 98, 78, 172, 31, 85, 132,
                59, 154, 202, 0, 128, 41, 160, 186, 65, 161, 205, 173, 93, 185, 43, 220, 161, 63,
                65, 19, 229, 65, 186, 247, 197, 132, 141, 184, 196, 6, 117, 225, 181, 8, 81, 198,
                102, 150, 198, 160, 112, 126, 42, 201, 234, 236, 168, 183, 30, 214, 145, 115, 201,
                45, 191, 46, 3, 113, 53, 80, 203, 164, 210, 112, 42, 182, 136, 223, 125, 232, 21,
                205,
            ][..],
            &[
                248, 117, 128, 134, 9, 24, 78, 114, 160, 0, 130, 39, 16, 128, 128, 164, 127, 116,
                101, 115, 116, 50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 96, 0, 87, 41, 160, 146, 204, 57, 32, 218, 236, 59, 94, 106, 72,
                174, 211, 223, 160, 122, 186, 126, 44, 200, 41, 222, 117, 117, 177, 189, 78, 203,
                8, 172, 155, 219, 66, 160, 83, 82, 37, 6, 243, 61, 188, 102, 176, 132, 102, 74,
                111, 180, 105, 33, 122, 106, 109, 73, 180, 65, 10, 117, 175, 190, 19, 196, 17, 128,
                193, 75,
            ][..],
        ];
        assert_signature(Chain::EthRopsten, signatures)
    }

    //TODO this signature is quite likely to change with GH-503 where we finally should be able to do things right
    #[test]
    fn signs_transaction_for_mumbai() {
        let signatures = &[
            &[
                248, 108, 9, 133, 4, 168, 23, 200, 0, 130, 82, 8, 148, 53, 53, 53, 53, 53, 53, 53,
                53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 136, 13, 224, 182, 179, 167,
                100, 0, 0, 128, 37, 160, 28, 207, 211, 218, 157, 116, 151, 209, 249, 25, 245, 9,
                235, 42, 117, 135, 140, 15, 233, 210, 28, 140, 94, 148, 71, 80, 222, 59, 202, 241,
                162, 128, 160, 39, 82, 37, 59, 77, 2, 70, 185, 180, 130, 90, 134, 250, 54, 215, 23,
                19, 1, 197, 2, 166, 152, 111, 236, 76, 85, 151, 113, 132, 119, 236, 177,
            ][..],
            &[
                248, 106, 128, 134, 213, 86, 152, 55, 36, 49, 131, 30, 132, 128, 148, 240, 16, 159,
                200, 223, 40, 48, 39, 182, 40, 92, 200, 137, 245, 170, 98, 78, 172, 31, 85, 132,
                59, 154, 202, 0, 128, 38, 160, 75, 9, 70, 21, 191, 87, 78, 224, 147, 37, 63, 237,
                234, 238, 87, 240, 94, 207, 253, 152, 175, 224, 8, 220, 158, 253, 37, 120, 147, 31,
                251, 227, 160, 99, 31, 144, 226, 86, 163, 6, 48, 45, 249, 196, 236, 227, 150, 182,
                113, 171, 13, 23, 2, 125, 195, 37, 188, 12, 34, 165, 80, 217, 53, 170, 9,
            ][..],
            &[
                248, 117, 128, 134, 9, 24, 78, 114, 160, 0, 130, 39, 16, 128, 128, 164, 127, 116,
                101, 115, 116, 50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 96, 0, 87, 38, 160, 11, 112, 169, 38, 48, 166, 229, 212, 193, 94,
                91, 195, 37, 139, 126, 160, 86, 161, 120, 107, 247, 242, 67, 243, 149, 48, 206,
                144, 31, 142, 122, 142, 160, 64, 207, 173, 83, 79, 59, 123, 34, 63, 114, 21, 166,
                239, 150, 254, 218, 100, 194, 232, 48, 47, 225, 243, 87, 134, 29, 219, 81, 206,
                157, 102, 5,
            ][..],
        ];
        assert_signature(Chain::PolyMumbai, signatures)
    }

    fn assert_signature(chain: Chain, collection_of_tx_signatures: &[&[u8]]) {
        let first_part_tx_1 = r#"[{"nonce": "0x9", "gasPrice": "0x4a817c800", "gasLimit": "0x5208", "to": "0x3535353535353535353535353535353535353535", "value": "0xde0b6b3a7640000", "data": []}, {"private_key": "0x4646464646464646464646464646464646464646464646464646464646464646", "signed": "#;
        let first_part_tx_2 = r#"[{"nonce": "0x0", "gasPrice": "0xd55698372431", "gasLimit": "0x1e8480", "to": "0xF0109fC8DF283027b6285cc889F5aA624EaC1F55", "value": "0x3b9aca00", "data": []}, {"private_key": "0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318", "signed": "#;
        let first_part_tx_3 = r#"[{"nonce": "0x00", "gasPrice": "0x09184e72a000", "gasLimit": "0x2710", "to": null, "value": "0x00", "data": [127,116,101,115,116,50,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,87]}, {"private_key": "0xe331b6d69882b4cb4ea581d88e0b604039a3de5967688d3dcffdd2270c0fd109", "signed": "#;
        fn compose(first_part: &str, slice: &[u8]) -> String {
            let third_part_jrc = "}]";
            format!("{}{:?}{}", first_part, slice, third_part_jrc)
        }
        let all_transactions = format!(
            "[{}]",
            vec![first_part_tx_1, first_part_tx_2, first_part_tx_3]
                .iter()
                .zip(collection_of_tx_signatures.iter())
                .zip(0usize..2)
                .fold(String::new(), |so_far, actual| [
                    so_far,
                    compose(actual.0 .0, actual.0 .1)
                ]
                .join(if actual.1 == 0 { "" } else { ", " }))
        );
        let txs: Vec<(RawTransaction, Signing)> = serde_json::from_str(&all_transactions).unwrap();
        let constant_parts = &[
            &[
                248u8, 108, 9, 133, 4, 168, 23, 200, 0, 130, 82, 8, 148, 53, 53, 53, 53, 53, 53,
                53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 136, 13, 224, 182, 179,
                167, 100, 0, 0, 128,
            ][..],
            &[
                248, 106, 128, 134, 213, 86, 152, 55, 36, 49, 131, 30, 132, 128, 148, 240, 16, 159,
                200, 223, 40, 48, 39, 182, 40, 92, 200, 137, 245, 170, 98, 78, 172, 31, 85, 132,
                59, 154, 202, 0, 128,
            ][..],
            &[
                248, 117, 128, 134, 9, 24, 78, 114, 160, 0, 130, 39, 16, 128, 128, 164, 127, 116,
                101, 115, 116, 50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 96, 0, 87,
            ][..],
        ];
        let lengths_of_constant_parts: Vec<usize> =
            constant_parts.iter().map(|part| part.len()).collect();
        for (((tx, signed), length), constant_part) in txs
            .iter()
            .zip(lengths_of_constant_parts)
            .zip(constant_parts)
        {
            let sign = tx.sign(
                &Wallet::from(
                    Bip32ECKeyPair::from_raw_secret(&signed.private_key.0.as_ref()).unwrap(),
                ),
                chain,
            );
            assert_eq!(sign, signed.signed);
            assert_eq!(sign[..length], **constant_part)
        }
    }

    //TODO I think the tests below just duplicate what the other tests already tested

    #[test]
    fn test_transfer_transaction_signing_ropsten() {
        let txt_txs_json = String::from(
            r#"[
            [{"nonce":"0x00","gasPrice":"0x3b9aca00","gasLimit":"0x0f4240","to":"0xcd6C588E005032dd882CD43Bf53a32129BE81302","value":"0x00","data":[169, 5, 156, 187, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 71, 251, 134, 113, 219, 131, 0, 141, 56, 44, 46, 110, 166, 127, 163, 119, 55, 140, 12, 234, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 99]}, {"private_key": "0x0fde24c464a9c55a83a164ec8f31888921549da2401a1af3cd79cccf5685421a", "signed": [248, 169, 128, 132, 59, 154, 202, 0, 131, 15, 66, 64, 148, 205, 108, 88, 142, 0, 80, 50, 221, 136, 44, 212, 59, 245, 58, 50, 18, 155, 232, 19, 2, 128, 184, 68, 169, 5, 156, 187, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 71, 251, 134, 113, 219, 131, 0, 141, 56, 44, 46, 110, 166, 127, 163, 119, 55, 140, 12, 234, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 99, 42, 160, 240, 147, 168, 58, 164, 16, 163, 171, 215, 39, 218, 5, 142, 236, 21, 21, 19, 126, 12, 160, 18, 49, 170, 75, 235, 248, 227, 239, 20, 86, 33, 188, 160, 23, 6, 133, 51, 6, 58, 162, 253, 93, 24, 232, 166, 152, 21, 78, 149, 194, 85, 96, 75, 208, 248, 164, 139, 100, 126, 89, 105, 31, 33, 123, 31]}],
            [{"nonce":"0x00","gasPrice":"0x3b9aca00","gasLimit":"0x2dc6c0","to":"0xcd6C588E005032dd882CD43Bf53a32129BE81302","value":"0x00","data":[169, 5, 156, 187, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 71, 251, 134, 113, 219, 131, 0, 141, 56, 44, 46, 110, 166, 127, 163, 119, 55, 140, 12, 234, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 99]}, {"private_key": "0x0fde24c464a9c55a83a164ec8f31888921549da2401a1af3cd79cccf5685421a", "signed": [248, 169, 128, 132, 59, 154, 202, 0, 131, 45, 198, 192, 148, 205, 108, 88, 142, 0, 80, 50, 221, 136, 44, 212, 59, 245, 58, 50, 18, 155, 232, 19, 2, 128, 184, 68, 169, 5, 156, 187, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 71, 251, 134, 113, 219, 131, 0, 141, 56, 44, 46, 110, 166, 127, 163, 119, 55, 140, 12, 234, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 99, 42, 160, 127, 123, 199, 240, 47, 239, 91, 20, 9, 5, 106, 179, 193, 5, 38, 243, 206, 162, 81, 140, 208, 17, 168, 105, 34, 90, 187, 113, 173, 121, 132, 37, 160, 79, 58, 225, 10, 3, 129, 227, 67, 219, 124, 112, 145, 94, 6, 46, 141, 12, 43, 41, 151, 122, 108, 77, 116, 206, 221, 86, 13, 75, 188, 162, 92]}]
        ]"#,
        );

        let txs: Vec<(RawTransaction, Signing)> = serde_json::from_str(&txt_txs_json).unwrap();
        let chain = Chain::EthRopsten;
        for (tx, signed) in txs.into_iter() {
            assert_eq!(
                signed.signed,
                tx.sign(
                    &Wallet::from(
                        Bip32ECKeyPair::from_raw_secret(&signed.private_key.0.as_ref()).unwrap()
                    ),
                    chain
                )
            );
        }
    }

    #[test]
    fn test_transfer_transaction_signing_mainnet() {
        let txt_txs_json = String::from(
            r#"[
            [{"nonce":"0x00","gasPrice":"0x04a817c800","gasLimit":"0x0493e0","to":"0x8D75959f1E61EC2571aa72798237101F084DE63a","value":"0x00","data":[169, 5, 156, 187, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 71, 251, 134, 113, 219, 131, 0, 141, 56, 44, 46, 110, 166, 127, 163, 119, 55, 140, 12, 234, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 99]}, {"private_key": "0x0fde24c464a9c55a83a164ec8f31888921549da2401a1af3cd79cccf5685421a", "signed": [248, 170, 128, 133, 4, 168, 23, 200, 0, 131, 4, 147, 224, 148, 141, 117, 149, 159, 30, 97, 236, 37, 113, 170, 114, 121, 130, 55, 16, 31, 8, 77, 230, 58, 128, 184, 68, 169, 5, 156, 187, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 71, 251, 134, 113, 219, 131, 0, 141, 56, 44, 46, 110, 166, 127, 163, 119, 55, 140, 12, 234, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 99, 38, 160, 119, 24, 174, 4, 103, 214, 218, 90, 184, 161, 214, 158, 165, 39, 8, 11, 37, 217, 24, 255, 239, 78, 217, 209, 140, 98, 207, 177, 97, 198, 80, 234, 160, 33, 134, 61, 21, 44, 79, 23, 207, 118, 217, 252, 231, 11, 189, 118, 184, 156, 79, 171, 157, 171, 131, 143, 129, 129, 42, 104, 0, 48, 52, 247, 151]}],
            [{"nonce":"0x00","gasPrice":"0x9502F9000","gasLimit":"0xd431","to":"0x8D75959f1E61EC2571aa72798237101F084DE63a","value":"0x00","data":[169, 5, 156, 187, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 71, 251, 134, 113, 219, 131, 0, 141, 56, 44, 46, 110, 166, 127, 163, 119, 55, 140, 12, 234, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 99]}, {"private_key": "0x0fde24c464a9c55a83a164ec8f31888921549da2401a1af3cd79cccf5685421a", "signed": [248, 169, 128, 133, 9, 80, 47, 144, 0, 130, 212, 49, 148, 141, 117, 149, 159, 30, 97, 236, 37, 113, 170, 114, 121, 130, 55, 16, 31, 8, 77, 230, 58, 128, 184, 68, 169, 5, 156, 187, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 71, 251, 134, 113, 219, 131, 0, 141, 56, 44, 46, 110, 166, 127, 163, 119, 55, 140, 12, 234, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 99, 38, 160, 9, 76, 204, 226, 14, 222, 72, 191, 217, 123, 150, 248, 98, 19, 182, 77, 179, 166, 231, 200, 31, 115, 239, 198, 179, 124, 115, 215, 74, 233, 208, 49, 160, 38, 52, 5, 216, 214, 17, 19, 130, 39, 94, 105, 1, 220, 10, 64, 176, 57, 13, 147, 74, 219, 228, 63, 240, 94, 161, 108, 181, 87, 185, 237, 207]}]
        ]"#,
        );

        let txs: Vec<(RawTransaction, Signing)> = serde_json::from_str(&txt_txs_json).unwrap();
        let chain = Chain::EthMainnet;
        for (tx, signed) in txs.into_iter() {
            assert_eq!(
                signed.signed,
                tx.sign(
                    &Wallet::from(
                        Bip32ECKeyPair::from_raw_secret(&signed.private_key.0.as_ref()).unwrap()
                    ),
                    chain
                )
            );
        }
    }
}
